%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  New template code for TAMU Theses and Dissertations starting Fall 2016.
%
%
%  Original Author: Sean Zachary Roberson
%  This version adapted for URS by Parasol lab.
%  Adapted from version 3.16.10, which was last updated on 9/29/2016.
%  URS adaptation last updated 1/9/2017.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           IMPLEMENTATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{THE IMPLEMENTATION}

\section{The Textbook}

For the implementation of the design, I have gone with proof of concept model. Taking a single textbook and applying this workflow for the purpose of working out any workflow issues and testing the algorithm in a real world situation. The textbook that will first be integrated is Dr. Philip B. Yasskin and Dr. Meade Mathematics textbook \textit{MYMACalc: A Web Based, Interactive, Multimedia Calculus}. This textbook was initially written in \LaTeX\;but has since been converted into a web based textbook.

\section{Textbook Build Process}

As aforementioned, the textbook is web based and as such, is developed to conform to web standards. Each page is written in Hypertext Markup Language (HTML). In order to better clarify as well as lighten the load on the author(s) of the textbook, a JavaScript object notation (JSON) file defines the order of the textbook. This order is similar to tree 1 as previously presented. From this ordering, the textbook is then built and structured. This JSON structure allows means that tree 1 is completed. Within tree 1, topics are then manually added to each unit in order to begin the process of building the other trees. Once these topics have been added, tree 3 and 5 can be generated by the implicit ordering defined by tree 1. The topics names are then replaced with ids of the topics. The author is then given the opportunity to then tweak trees 3 and 5 to indicate the correct dependency mapping of these trees. 


\section{The Tech Stack}

\subsection{Database}

A graph database is utilized for storing the five different trees. The particular database used was Neo4j. This database allowed for DAGs to be stored in it's entirety. It also allowed for each querying and finding of nodes by simply information about the node. There was also an interface provided by this service that would visually show nodes that are matched by a given query as well as the relationship between each node. 

\subsection{Server}

The purpose of the server was to fetch and store data to the database and perform the computational portions of the algorithm. This included identifying warning messages and ensuring that all dependencies are met for each change or modification that a consumer makes. 

\subsection{Client}

The client utilized ReactJS. This is front end library that had existing modules that allowed for easily modifying and reordering a JSON tree. This was not a simple implementation so it did require a good amount of tweaking in order for it to fit the necessary use case.

\section{Integration with Textbook}

Full integration with the textbook involves two different parts. One is adding all 5 textbook trees for use by the platform and the other is being able to export the necessary data in order to actually modify the textbook. As mentioned previously, the textbook being used had a good portion of tree 1 completed. With some effort and additional mapping, trees 2, 3, 4 and 5 can be constructed.

\subsection{Import Process}

The import process put simply requires the original author to upload all five trees. From there the server is then able to validate and identify if there are any possible dependencies not satisfied in trees 1 and 2. If there are, the author is then provided messages as to what dependencies are not met and allows the autor to modify them using the graphical user interface. This graphical user interface is the same as the one the consumer uses for reordering latter on.

\subsection{Reorder Process}

This is the process where the consumer has the control to modify the structure of the units and the exercises. There are two views for accomplishing this. One is focused on simply the unit and the other focuses more on the exercises and the the units they are directly tied to. During each modification or tweak that lasts for longer than two seconds, the new and updated tree is sent to the server for verification. The server then verifies dependencies and identifies if any have been violated. Depending on the order of the violation and where in the tree the violation occurred, a message is generated to inform the consumer of what the violations are and possible suggestions as to how to fix the ordering.

After the consumer has modified the ordering of the units, they are able to review these changes. This review screen highlights changes, additions or deletions of units. This screen allows the user to see all the changes they are attempting to do before they commit them. Once the user approves these changes, this new ordering is then stored as the new ordering for the particular consumer. Along with storing these changes, the consumer is given the option to allow tree 2 to be automatically generated. Regardless of if the user allows for this to happen, they are then taken to the exercise reordering screen. The same reordring for units then follows with warnings and messages appearing as well as the review screen showing before a user fully commits their ordering changes. 

\subsection{Export Process}

Due to the structure and modifications to the build process of the textbook in use, the export process is rather trivial. It is simply an export of trees 1 and 2. With the textbook in use, especially with tree 1, these trees in JSON format are then placed in the appropriate location in the build process. This allows for the existing build process to generate the new ordering of the textbook as specified by the consumer.
